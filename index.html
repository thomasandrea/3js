<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <link rel="stylesheet" href="style.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3d App</title>
  </head>
  <body>


    <h1 class="logoBitmama"><img src="./logo_bitmama_white.svg"></h1>
    <script type="module" src="/main.js"></script>
    <!--<canvas id="webgl-canvas" class="webglCanvas"></canvas>-->

    <!--<script>
const webglCanvas = document.getElementById('webgl-canvas');
const gl = webglCanvas.getContext('webgl');

if (!gl) {
    console.error("WebGL not supported");
}

// Imposta le dimensioni del canvas a quelle della finestra
webglCanvas.width = window.innerWidth;
webglCanvas.height = window.innerHeight;
gl.viewport(0, 0, webglCanvas.width, webglCanvas.height);

// Shader per vertici
const vertexShaderSource = `
    attribute vec2 position;
    void main() {
        gl_Position = vec4(position, 0.0, 1.0);
    }
`;

// Shader per frammenti con scia particellare
const fragmentShaderSource = `
    precision mediump float;
    uniform vec2 mousePos;
    uniform float time;
    void main() {
        // Distanza dal mouse
        float dist = length(gl_FragCoord.xy - mousePos);
        
        // Intensità che svanisce velocemente
        float alpha = exp(-dist * 0.01) * 0.6;
        
        // Scia luminosa bianca con bordi rossi
        vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(1.0), smoothstep(0.0, 0.5, alpha));
        
        // Output del colore con opacità dissolvente
        gl_FragColor = vec4(color, alpha);
    }
`;

// Funzione per compilare shader
function compileShader(source, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("ERROR compiling shader: ", gl.getShaderInfoLog(shader));
    }
    return shader;
}

// Creazione shader e programma
const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// Buffer per il quadrato che copre tutta la finestra
const vertices = new Float32Array([
    -1.0, -1.0,
     1.0, -1.0,
    -1.0,  1.0,
     1.0,  1.0
]);

const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

const positionLocation = gl.getAttribLocation(program, 'position');
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(positionLocation);

// Uniform per posizione mouse e tempo
const mousePosLocation = gl.getUniformLocation(program, 'mousePos');
const timeLocation = gl.getUniformLocation(program, 'time');

// Gestione del mouse
let mousePos = [0, 0];
window.addEventListener('mousemove', (event) => {
    mousePos = [event.clientX, webglCanvas.height - event.clientY];
});

// Rendering a schermo intero
function animate(time) {
    gl.clearColor(0.0, 0.0, 0.2, 1.0);  // Background blu scuro
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.uniform2fv(mousePosLocation, mousePos);
    gl.uniform1f(timeLocation, time * 0.001);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    requestAnimationFrame(animate);
}

animate(0);
  </script>-->
  
    
  </body>
</html>
